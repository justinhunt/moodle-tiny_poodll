{"version":3,"file":"base_recorder.min.js","sources":["../src/base_recorder.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny Poodll - audio recorder configuration.\n *\n * @module      tiny_poodll/audio_recorder\n * @copyright   2023 Justin Hunt <justin@poodll.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\nimport Log from 'core/log';\nimport {getConfig} from './options';\nimport * as ModalFactory from 'core/modal_factory';\nimport * as Templates from 'core/templates';\nimport {prefetchStrings, prefetchTemplates} from 'core/prefetch';\nimport Modal from \"./modal\";\nimport ModalRegistry from 'core/modal_registry';\nimport History from 'tiny_poodll/history';\n\nimport {\n    component,\n    INSERTMETHOD,\n    LANGUAGE,\n    CSS,\n    SKIN\n} from './common';\n\n/**\n * The Poodll base class for audio, video, and any other future types\n */\nexport default class {\n\n    /**\n     * Constructor for the Tiny Poodll Recorder\n     *\n     * @param {TinyMCE} editor The Editor to which the content will be inserted\n     * @param {elementid} elementid\n     * @param {Modal} modal The Moodle Modal that contains the interface used for recording\n     * @param {config} config The data passed to template and used internally for managing plugin state\n     */\n    constructor(editor,elementid, modal, config) {\n        this.ready = false;\n\n        this.editor = editor;\n        this.elementid = elementid;\n        this.config = config;//getData(editor).params;\n        this.modal = modal;\n        this.modalRoot = modal.getRoot()[0];\n        this.registerEvents();\n        this.ready = true;\n    }\n\n    /**\n     * Get the name of the template used when embedding the URL in the editor content.\n     *\n     * @returns {string}\n     */\n    fetchMediaTags() {\n        throw new Error(`fetchMediaTags() must be implemented in ${this.constructor.name}`);\n    }\n\n    /**\n     * Close the modal and stop recording.\n     */\n    close() {\n        // Closing the modal will destroy it and remove it from the DOM.\n        // It will also stop the recording via the hidden Modal Event.\n        this.modal.hide();\n    }\n\n    getElement(component){\n        return this.modalRoot.querySelector('#' + this.elementid + '_' + component);\n    }\n\n    /**\n     * Register event listeners for the modal.\n     */\n    registerEvents() {\n        var that =this;\n        const $root = this.modal.getRoot();\n        const root = $root[0];\n        const recorders = root.querySelectorAll('.' + CSS.CP_SWAP);\n\n\n        root.addEventListener('click', (e) => {\n            const cbox = e.target.closest('[type=\"checkbox\"]');\n           // if (cbox) {\n            Log.debug(e.target.id);\n                switch (e.target.id) {\n                    case that.elementid + '_' + CSS.SUBTITLE_CHECKBOX:\n                        //update recorder subtitle setting\n                        if (cbox.checked) {\n                            recorders.forEach((recorder) => {\n                                recorder.setAttribute('data-transcribe', '1');\n                                recorder.setAttribute('data-subtitle', '1');\n                                recorder.setAttribute('data-alreadyparsed', 'false');\n                                recorder.innerHTML = \"\";\n                            });\n                            that.config.subtitling = true;\n                        } else {\n                            recorders.forEach((recorder) => {\n                                recorder.setAttribute('data-transcribe', '0');\n                                recorder.setAttribute('data-subtitle', '0');\n                                recorder.setAttribute('data-alreadyparsed', 'false');\n                                recorder.innerHTML = \"\";\n                            });\n                            that.config.subtitling = false;\n                        }\n                        //reload the recorders\n                        that.loadRecorders();\n                        break;\n                    case  that.elementid + '_' + CSS.MEDIAINSERT_CHECKBOX:\n                        //update recorder subtitle setting\n                        if (cbox.checked) {\n                            that.config.insertmethod = INSERTMETHOD.TAGS;\n                        } else {\n                            that.config.insertmethod = INSERTMETHOD.LINK;\n                        }\n                        break;\n                }\n           // }\n        });\n        root.addEventListener('change', (e) => {\n            const dropdown = e.target;\n            if(dropdown){\n                switch(dropdown.id){\n                    case that.elementid + '_' + CSS.LANG_SELECT:\n                        //TO DO - save this value, or leave it as is ... do we need to keep track of it, for insert method?\n                        that.config.CP.language =dropdown.get('value');\n                        recorders.forEach((recorder) => {\n                            recorder.setAttribute('data-language', that.config.CP.language);\n                            recorder.setAttribute('data-alreadyparsed', 'false');\n                            recorder.innerHTML=\"\";\n                        });\n                        that.loadRecorders();\n                        break;\n                    case that.elementid + '_' + CSS.EXPIREDAYS_SELECT:\n                        //do something\n                        recorders.forEach((recorder) => {\n                            recorder.setAttribute('data-expiredays', that.config.CP.expiredays);\n                            recorder.setAttribute('data-alreadyparsed', 'false');\n                            recorder.innerHTML=\"\";\n                        });\n                        that.loadRecorders();\n                }\n\n            }\n\n        });\n\n    }\n\n    /**\n     * Initialises history tab and events\n     *\n     * @method initHistory\n     * @private\n     */\n    initHistory(elementid) {\n        Log.debug('initialising history');\n        this.history = new History(this);\n    }\n\n    /**\n     * Loads or reloads the recorders\n     *\n     * @method _loadRecorders\n     * @private\n     */\n    loadRecorders() {\n        var that = this;\n        Log.debug('loading recorders');\n        that.uploaded = false;\n        that.ap_count = 0;\n        require(['tiny_poodll/cloudpoodllloader'], function (loader) {\n            var recorder_callback = function (evt) {\n                switch (evt.type) {\n                    case 'recording':\n                        if (evt.action === 'started') {\n                            //if user toggled subtitle checkbox any time from now, the recording would be lost\n                            var subtitlecheckbox= that.getElement(CSS.SUBTITLE_CHECKBOX);\n                            if (subtitlecheckbox !== null) {\n                                subtitlecheckbox.disabled = true;\n                            }\n                        }\n                        break;\n                    case 'awaitingprocessing':\n                        //we delay  a second to allow the sourcefile to be copied to correct location\n                        //the source filename will sometimes be incorrect, we do not know it when creating the db entry\n                        // but its ok. Most players ignore the extension and deal with contents\n                        if (!that.uploaded) {\n                            setTimeout(function () {\n                                var guessed_ext = loader.fetch_guessed_extension(that.recorder );\n                                var sourcefilename = evt.sourcefilename.split('.').slice(0, -1).join('.')\n                                    + '.' + guessed_ext;\n                                var sourceurl = evt.s3root + sourcefilename;\n                                //save history\n                                Log.debug(\"saving history item\");\n                                that.history.saveHistoryItem(evt.mediaurl,evt.mediafilename, sourceurl, evt.sourcemimetype).then(\n                                    function(){Log.debug(\"ajax SAVED history item\");}\n                                );\n                                that.doInsert(evt.mediaurl, evt.mediafilename, sourceurl, evt.sourcemimetype);\n                            }, 4000);\n                            that.uploaded = true;\n                        }\n                        break;\n                    case 'filesubmitted':\n                        //we will probably never get here because awaiting processing will fire first\n                        //we do not use this event, but it arrives when the final file is ready.\n\n                        break;\n                    case 'error':\n                        alert('PROBLEM:' + evt.message);\n                        break;\n                }\n            };\n            loader.init(CSS.CP_SWAP, recorder_callback);\n        });\n    }\n\n\n    /**\n     * Creates the media link based on the recorder type.\n     *\n     * @method fetchMediaLink\n     * @param {string} mediaurl media URL to the AWS object\n     * @param {string} mediafilename File name of the AWS object\n     * @param {string} sourceurl URL to the AWS object\n     * @param {string} sourcemimetype MimeType of the AWS object\n     * @private\n     */\n    fetchMediaLink(mediaurl, mediafilename, sourceurl, sourcemimetype) {\n        var context = {};\n        context.url = mediaurl;\n        context.name = mediafilename;\n        context.issubtitling = this.config.subtitling && this.config.subtitling !== '0';\n        var includesource = this.config.includesource == \"1\";\n        context.includesourcetrack = includesource && this.config.transcoding\n            && (mediaurl !== sourceurl)\n            && (sourceurl.slice(-3) !== 'wav')\n            && (sourceurl !== false);\n        context.CP = this.config.CP;\n        context.subtitleurl = mediaurl + '.vtt';\n        context.sourceurl = sourceurl;\n        context.sourcemimetype = sourcemimetype;\n        return Templates.renderForPromise(\n            'tiny_poodll/medialink',\n            context\n        );\n    }\n\n    /**\n     * Inserts the link or media element onto the page\n     * @method doInsert\n     * @param {string} mediaurl media URL to the AWS object\n     * @param {string} mediafilename File name of the AWS object\n     * @param {string} sourceurl URL to the AWS object\n     * @param {string} sourcemimetype MimeType of the AWS object\n     * @private\n     */\n    doInsert(mediaurl, mediafilename, sourceurl, sourcemimetype) {\n\n        var that = this;\n\n        //do the actual inserting\n        switch (this.config.insertmethod) {\n\n            case INSERTMETHOD.TAGS:\n                this.fetchMediaTags(mediaurl, mediafilename, sourceurl, sourcemimetype).then(\n                    function(insert){\n                        Log.debug('inserting into editor');\n                        that.editor.insertContent(insert.html);\n                        that.close();\n                        //addToast(await getString('recordinguploaded', component));\n                    }\n                );\n                break;\n\n            case INSERTMETHOD.LINK:\n            default:\n                this.fetchMediaLink(mediaurl, mediafilename, sourceurl, sourcemimetype).then(\n                    function(insert){\n                        Log.debug('inserting into editor');\n                        Log.debug(insert.html);\n                        that.editor.insertContent(insert.html);\n                        that.close();\n                    }\n                );\n\n        }\n\n    } //end of doinsert\n\n\n    static generateRandomString() {\n        var length = 8;\n        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var result = '';\n\n        for (var i = 0; i < length; i++) {\n            var randomIndex = Math.floor(Math.random() * characters.length);\n            result += characters.charAt(randomIndex);\n        }\n\n        return result;\n    }\n\n    static getModalClass() {\n        const modalType = `${component}/media_recorder`;\n        const registration = ModalRegistry.get(modalType);\n        if (registration) {\n            return registration.module;\n        }\n\n        const MediaModal = class extends Modal {\n            static TYPE = modalType;\n            static TEMPLATE = `${component}/recorders`;\n        };\n\n        ModalRegistry.register(MediaModal.TYPE, MediaModal, MediaModal.TEMPLATE);\n        return MediaModal;\n    }\n\n    static getModalContext(editor) {\n\n        var context = {};\n        var config = getConfig(editor);\n        Log.debug(config);\n        //stuff declared in common\n        context.CSS = CSS;\n\n        //insert method\n        context.insertmethod = config.insertmethod;\n\n        //subtitle by default\n        context.subtitleaudiobydefault = config.subtitleaudiobydefault;\n        context.subtitlevideobydefault = config.subtitlevideobydefault;\n\n        //transcoding flag\n        context.transcoding = config.cp_transcode == '1';\n\n        //file title display length\n        context.filetitledisplaylength = config.filetitle_displaylength;\n\n        //Include source\n        context.includesource = config.includesource == '1';\n\n        //show tabs\n        context.showhistory = config.showhistory== '1';\n        context.showupload = config.showupload== '1';\n        context.showoptions = config.showoptions== '1';\n        context.showexpiredays = config.showexpiredays== '1';\n        context.cansubtitle = config.cp_cansubtitle;\n\n        //set up the cloudpoodll div\n        context.CP={};\n        context.CP.parent = M.cfg.wwwroot;\n        context.CP.appid = 'tiny_poodll';\n        context.CP.token = config.cp_token;\n        context.CP.region = config.cp_region;\n        context.CP.owner = config.cp_owner;\n        context.CP.expiredays = config.cp_expiredays;\n        context.CP.cansubtitle = config.cp_cansubtitle;\n        context.CP.language = config.cp_language;\n        context.CP.transcode = config.cp_transcode;\n        context.CP.audioskin = config.cp_audioskin;\n        context.CP.videoskin = config.cp_videoskin;\n        context.CP.fallback = config.fallback;\n        context.CP.cloudpoodllurl = config.cp_cloudpoodllurl;\n        context.CP.sizes = this.fetchRecorderDimensions(config);\n\n        //get defaults for expire days and subtitle language\n        context['expire_' + config.cp_expiredays] =true;\n        context['lang_' + config.cp_language] =true;\n\n        return context;\n    }\n\n    static async display(editor) {\n        const ModalClass = this.getModalClass();\n        const templatecontext = this.getModalContext(editor);\n        const elementid = 'tph_' + this.generateRandomString();\n        templatecontext.elementid = elementid;\n\n        const modal = await ModalFactory.create({\n            type: ModalClass.TYPE,\n            templateContext: templatecontext,\n            large: true,\n        });\n\n        // Set up the Recorder.\n        const recorder = new this(editor, elementid, modal, templatecontext);\n        recorder.loadRecorders();\n        recorder.initHistory();\n\n        modal.show();\n        return modal;\n    }\n}"],"names":["constructor","editor","elementid","modal","config","ready","modalRoot","getRoot","registerEvents","fetchMediaTags","Error","this","name","close","hide","getElement","component","querySelector","that","root","recorders","querySelectorAll","CSS","CP_SWAP","addEventListener","e","cbox","target","closest","debug","id","SUBTITLE_CHECKBOX","checked","forEach","recorder","setAttribute","innerHTML","subtitling","loadRecorders","MEDIAINSERT_CHECKBOX","insertmethod","INSERTMETHOD","TAGS","LINK","dropdown","LANG_SELECT","CP","language","get","EXPIREDAYS_SELECT","expiredays","initHistory","history","History","uploaded","ap_count","require","loader","init","evt","type","action","subtitlecheckbox","disabled","setTimeout","guessed_ext","fetch_guessed_extension","sourcefilename","split","slice","join","sourceurl","s3root","saveHistoryItem","mediaurl","mediafilename","sourcemimetype","then","doInsert","alert","message","fetchMediaLink","context","url","issubtitling","includesource","includesourcetrack","transcoding","subtitleurl","Templates","renderForPromise","insert","insertContent","html","characters","result","i","randomIndex","Math","floor","random","length","charAt","modalType","registration","ModalRegistry","module","MediaModal","Modal","register","TYPE","TEMPLATE","subtitleaudiobydefault","subtitlevideobydefault","cp_transcode","filetitledisplaylength","filetitle_displaylength","showhistory","showupload","showoptions","showexpiredays","cansubtitle","cp_cansubtitle","parent","M","cfg","wwwroot","appid","token","cp_token","region","cp_region","owner","cp_owner","cp_expiredays","cp_language","transcode","audioskin","cp_audioskin","videoskin","cp_videoskin","fallback","cloudpoodllurl","cp_cloudpoodllurl","sizes","fetchRecorderDimensions","ModalClass","getModalClass","templatecontext","getModalContext","generateRandomString","ModalFactory","create","templateContext","large","show"],"mappings":"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"}